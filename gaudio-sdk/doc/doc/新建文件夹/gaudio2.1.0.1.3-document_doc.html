<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
    <title>The Geek Audio SDK Library</title>
    <link rel="stylesheet" href="doc.css" type="text/css"/>
  </head>

  <body>
    <h1>The Geek Audio SDK Library (GAudio)</h1>

    <h1>Contents</h1>

    <ul>
      <li>
        <a href="#ReleaseHistory">Release History</a>
      </li>
      <li>
        <a href="#Introduction">Introduction</a>
        <ul>
          <li><a href="#Licensing">Licensing</a></li>
          <li><a href="#History">Some History</a></li>
          <li><a href="#OpenGLGLUT">OpenGL, GLUT and using what you already know</a></li>
        </ul>
      </li>
      <li>
        <a href="#CompilingLinking">Compiling and Linking</a>
      </li>
      <li>
        <a href="#API">The GAudio API</a>
        <ul>
          <li>
            <a href="#ErrorHandling">Error Handling</a>
            <ul>
              <li><a href="#gaudio_error_get">gaudio_error_get</a></li>
            </ul>
          </li>
          <li>
            <a href="#InitializationExit">Initialization / Exit</a>
            <ul>
              <li><a href="#gaudio_init">gaudio_init</a></li>
              <li><a href="#gaudio_deinit">gaudio_deinit</a></li>
            </ul>
          </li>
          <li>
            <a href="#source">Source</a>
            <ul>
              <li><a href="#gaudio_source_create_from_file">gaudio_source_create_from_file</a></li>
              <li><a href="#gaudio_source_create_from_buffer">gaudio_source_create_from_buffer</a></li>
              <li><a href="#gaudio_source_create_from_virtual_io">gaudio_source_create_from_virtual_io</a></li>
              <li><a href="#gaudio_source_create_from_buffer2">gaudio_source_create_from_buffer2</a></li>
              <li><a href="#gaudio_source_destroy">gaudio_source_destroy</a></li>
              <li><a href="#gaudio_source_set_user">gaudio_source_set_user</a></li>
              <li><a href="#gaudio_source_get_user">gaudio_source_get_user</a></li>
              <li><a href="#gaudio_source_set_finish_callback">gaudio_source_set_finish_callback</a></li>
              <li><a href="#gaudio_source_set_error_callback">gaudio_source_set_error_callback</a></li>
              <li><a href="#gaudio_source_set_float3">gaudio_source_set_float3</a></li>
              <li><a href="#gaudio_source_get_float3">gaudio_source_get_float3</a></li>
              <li><a href="#gaudio_source_set_float">gaudio_source_set_float</a></li>
              <li><a href="#gaudio_source_get_float">gaudio_source_get_float</a></li>     
              <li><a href="#gaudio_source_get_int32">gaudio_source_get_int32</a></li>
              <li><a href="#gaudio_source_set_int32">gaudio_source_set_int32</a></li>
              <li><a href="#gaudio_source_get_string">gaudio_source_get_string</a></li>                        
              <li><a href="#gaudio_source_start">gaudio_source_start</a></li>
              <li><a href="#gaudio_source_start_3d">gaudio_source_start_3d</a></li>
              <li><a href="#gaudio_source_pause">gaudio_source_pause</a></li>
              <li><a href="#gaudio_source_stop">gaudio_source_stop</a></li>
              <li><a href="#gaudio_source_seek">gaudio_source_seek</a></li>
              <li><a href="#gaudio_source_set_position_callback">gaudio_source_set_position_callback</a></li>               
            </ul>
          </li>
          <li>
            <a href="#effect">Effect</a>
            <ul>
              <li><a href="#gaudio_effect_create">gaudio_effect_create</a></li>
              <li><a href="#gaudio_effect_destroy">gaudio_effect_destroy</a></li>
              <li><a href="#gaudio_effect_bind">gaudio_effect_bind</a></li>
              <li><a href="#gaudio_effect_bind_to_source">gaudio_effect_bind_to_source</a></li>

              <li><a href="#gaudio_effect_unbind">gaudio_effect_unbind</a></li>
              <li><a href="#gaudio_effect_unbind_from_source">gaudio_effect_unbind_from_source</a></li>
              <li><a href="#gaudio_effect_set_float">gaudio_effect_set_float</a></li>
              <li><a href="#gaudio_effect_get_float">gaudio_effect_get_float</a></li> 
              <li><a href="#gaudio_effect_set_int32">gaudio_effect_set_int32</a></li>
              <li><a href="#gaudio_effect_get_int32">gaudio_effect_get_int32</a></li>                              
            </ul>
          </li>
          <li>
            <a href="#recorder">Recorder</a>
            <ul>
              <li><a href="#gaudio_recorder_create">gaudio_recorder_create</a></li>
              <li><a href="#gaudio_recorder_destroy">gaudio_recorder_destroy</a></li>
              <li><a href="#gaudio_recorder_start">gaudio_recorder_start</a></li>
              <li><a href="#gaudio_recorder_stop">gaudio_recorder_stop</a></li>
            </ul>
          </li>  
          <li>
            <a href="#listener">Listener</a>
            <ul>
              <li><a href="#gaudio_listener_set_float3">gaudio_listener_set_float3</a></li>
              <li><a href="#gaudio_listener_get_float3">gaudio_listener_set_float3</a></li>
            </ul>
          </li>                   
          <li>
            <a href="#misc">Misc.</a>
            <ul>
              <li><a href="#gaudio_is_support">gaudio_is_support</a></li>
              <li><a href="#gaudio_set_float">gaudio_set_float</a></li>
              <li><a href="#gaudio_get_float">gaudio_get_float</a></li>
              <li><a href="#gaudio_set_int32">gaudio_set_int32</a></li>
              <li><a href="#gaudio_get_int32">gaudio_get_int32</a></li>
              <li><a href="#gaudio_set_string">gaudio_set_string</a></li>
              <li><a href="#gaudio_get_string">gaudio_get_string</a></li>
              <li><a href="#gaudio_address_get">gaudio_address_get</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <h1><a name="ReleaseHistory"></a>Release History</h1>

    <ul>
      <li>2013-04-01: Version 0.5.5.0 </li>
      <li>2013-04-10: Version 1.0.1 0 </li>
      <li>2013-05-01: Version 1.4.0.8 </li>
      <li>2013-05-10: Version 1.6.8.0 </li>
      <li>2013-06-10: Version 1.7.2.0 </li>
      <li>2013-07-07: Version 1.8.0.2 </li>
      <li>2013-07-29: Version 1.9.8.6 </li>
      <li>2013-08-16: Version 2.0.0.1 </li>
      <li>2013-09-18: Version 2.0.6.0 </li>
      <li>2006-10-05: Version 2.1.0.1 </li>
    </ul>

    <h1><a name="Introduction"></a>Introduction</h1>

    <p>GAudio is a powerfull high level, cross-platform API for playing back
    sound like games and multimedia applications. GAudio is free for
    non-commercial use. There is also an advanced version of GAudio named
    'GAudio pro' which can be purchased for a small license fee and may be used
    in commercial products.</p>

    <div class="example">
      <h4>Example: 'Hello, world' in GAudio</h4>

      <p>Here is the traditional first program for any language or library, but
      this time it is actually <em>saying</em> 'Hello, world!' instead of
      printing it:</p>

<pre class="programlisting">#include &lt;stdlib.h&gt;
#include &lt;gaudio.h&gt;

int main (int argc, char **argv)
{

#ifdef WIN32 
    gaudio_init("addons"); 
#else 
    gaudio_init("/usr/local/lib/gaudio/"); 
#endif
    gsource* source = gaudio_source_create_from_file(filename,FALSE);
    gaudio_source_start(source,FALSE);
    printf("\nplaying, press any key to quit.\n"); 
    getch();
    gaudio_source_stop(source); 
    gaudio_source_destroy(source); 
    gaudio_deinit();    
    return EXIT_SUCCESS;
}
</pre>

      <p>Note that there error checks are missing in the program above to keep
      it simple.</p>

    </div>

    <h3><a name="CompilingLinking"></a>Compiling and Linking</h3>

    <p>All GAudio programs should contain:</p>

<pre class="programlisting">#include &lt;gaudio.h&gt;
</pre>

    <p>The GAudio header includes <tt>&lt;gaudio.h&gt;</tt> and other effect definational
        files for you so you don't need to include them again -
    although it does not hurt to do so. GAudio reserves the "gaudio<tt>_</tt>&quot; prefix for preprocessor macros, so you should
    never define such a macro in your own program. Furthermore, you should not
    rely on any macro starting with "gaudio<tt>_</tt>&quot; not mentioned in
    this specification.</p>

    <p>If you are using the GAudio, which is available via the <a href="http://www.gaudio.org/"> GAudio homepage</a>, you can find
    out the necessary compilation flags by using one of the following
    commands:</p>

<pre class="screen">pkg-config --cflags gaudio
gaudio-config --cflags
</pre>

    <p>To find out the necessary flags for linking, use one of the following
    commands:</p>

<pre class="screen">pkg-config --libs gaudio
gaudio-config --libs
</pre>

    <p>On Windows, link with <span style="font-size: 10pt">gaudio</span><tt>.dll</tt>.</p>

    <p>
        GAudio reserves the "gaudio_" prefix for globally visible
    functions and variables, so you should never define such a function or
    variable in your own program. Furthermore, you should not rely on any such
    function or variable not mentioned in this specification.</p>

    <h1><a name="API"></a>The GAudio API</h1>

    <h2><a name="ErrorHandling"></a>Error Handling</h2>

    <p>There is gaudio_error_get which can get current status of GAudio library.
    Function - gaudio_error_get return value, where <tt>AUDIO_NO_ERROR</tt> /
    <tt>AUDIO_NOT_INIT</tt> / <tt>AUDIO_BAD_TAG</tt> / <tt>AUDIO_BAD_VALUE</tt>/
    <tt>AUDIO_NOT_SUPPORT</tt> / <tt>AUDIO_BAD_OPERATION</tt> /
    <tt>AUDIO_OUT_OF_MEMORY</tt> / <tt>AUDIO_INNER_ERROR</tt> /
    <tt>gaudio_error_get</tt> can be used to find out what exactly went wrong.</p>

    <p>It is guaranteed that if a function fails, no data pointed to by pointer
    arguments has been changed.</p>

    <h3 class="manpage"><a name="gaudio_error_get"></a>gaudio_error_get</h3>

    <h4>Name</h4>

    <p><tt>gaudio_error_get</tt> - return and clear the current error state</p>

    <h4>Synopsis</h4>

<pre class="programlisting">int32_t gaudio_error_get(void);
</pre>

    <h4>Description</h4>

    <p>Any ALUT routine that fails will return <tt>AL_FALSE</tt> /
    <tt>AL_NONE</tt> / <tt>NULL</tt> and set the global error state. If a
    subsequent error occurs while there is still an error recorded internally,
    the second error will simply be ignored. Calling <tt>alutGetError</tt> will
    reset the error code to <tt>ALUT_ERROR_NO_ERROR</tt>. Note that the error
    state is <em>not</em> cleared by other successful ALUT calls.</p>

    <h4>Return Value</h4>

    <p><tt>gaudio_error_get</tt> returns the contents of the global error state,
    which can be one of the following values:</p>

    <dl>
      <dt><tt>AUDIO_NO_ERROR</tt></dt>
      <dd>No GAudio error found.</dd>

      <dt><tt>AUDIO_NOT_INIT</tt></dt>
      <dd>No initialized.</dd>

      <dt><tt>AUDIO_BAD_TAG</tt></dt>
      <dd>Invalid input tag parameter.</dd>

      <dt><tt>AUDIO_BAD_VALUE</tt></dt>
      <dd>Invalid input value parameter.</dd>

      <dt><tt>AUDIO_NOT_SUPPORT</tt></dt>
      <dd>GAudio don't support this function.</dd>

      <dt><tt>AUDIO_BAD_OPERATION</tt></dt>
      <dd>This operation is prohibited.</dd>

      <dt><tt>AUDIO_OUT_OF_MEMORY</tt></dt>
      <dd>Out of memory -- some malloc() failed.</dd>

      <dt><tt>AUDIO_INNER_ERROR</tt></dt>
      <dd>GAudio internal error.</dd>
    </dl>

    <h4>Errors</h4>

    <p><tt>gaudio_error_get</tt> can be called in any GAudio state and will never
    fail.</p>

    <h2><a name="InitializationExit"></a>Initialization / Exit</h2>

    <p>
        GAudio starts in an <em>uninitialized</em> state.&nbsp; gaudio_init put gaudio into the <em>initialized</em>
    state. Those functions must only be called when the state is
    <em>uninitialized</em>. <tt>gaudio_deinit</tt> puts gaudio back from an
    <em>initialized</em> state to an <em>uninitialized</em> one.</p>

    <h3 class="manpage"><a name="gaudio_init"></a>gaudio_init</h3>

    <h4>Name</h4>

    <p><tt>&nbsp; &nbsp;gaudio_init</tt> - initialize the GAudio library and create a default
    current context</p>

    <h4>Synopsis</h4>

<pre class="programlisting">
void gaudio_init(const char* addons);
</pre>

    <h4>Description</h4>

    <p><tt>gaudio_init</tt> initializes the GAudio internals and loads GAudio 's addons. </p>

    <h3 class="manpage"><a name="gaudio_deinit"></a>gaudio_deinit</h3>

    <h4>Name</h4>

    <p><tt>gaudio_deinit</tt> - shutdown the GAudio library</p>

    <h4>Synopsis</h4>

    <pre class="programlisting">void gaudio_deinit(void);</pre>

    <h4>Description</h4>

    <p>When the application has finished playing or recordering audio, it should
    shut down GAudio using <tt>gaudio_deinit</tt>. This closes GAudio context
    that GAudio may have created in <tt>gaudio_deinit</tt> and unloads addons.
    After calling <tt>gaudio_deinit</tt>, you may subsequently call
    <tt>gaudio_init</tt> again.</p>

    <h2><a name="source"></a>Sound Sample File Loading</h2>

    <h3 class="manpage"><a name="gaudio_deinit"></a>gaudio_deinit</h3>

    <h4>Name</h4>

    <p><tt>alutExit</tt> - shutdown the ALUT library</p>

    <h4>Synopsis</h4>

<pre class="programlisting">ALboolean alutExit (void);
</pre>

    <h4>Description</h4>

    <p>When the application has finished playing audio, it should shut down ALUT
    using <tt>aluExit</tt>. This closes any OpenAL device/context that ALUT may
    have created in <tt>alutInit</tt> (but not any that the application created
    using ALC). After calling <tt>alutExit</tt>, you may subsequently call
    <tt>alutInit</tt> or <tt>alutInitWithoutContext</tt> again. Note that under
    well-behaved operating systems, it should be acceptable to simply exit from
    your program without bothering to call <tt>alutExit</tt>, relying on the OS
    to clean up after you. However, it is dangerous to rely on this behavior if
    portable operation is expected.</p>

    <h4>Return Value</h4>

    <p><tt>alutExit</tt> returns <tt>AL_TRUE</tt> on success or
    <tt>AL_FALSE</tt> on failure.</p>

    <h4>Errors</h4>

    <dl>
      <dt><tt>ALUT_ERROR_INVALID_OPERATION</tt></dt>
      <dd>ALUT has not been initialised.</dd>

      <dt><tt>ALUT_ERROR_NO_CURRENT_CONTEXT</tt></dt>
      <dd>There is no current AL context.</dd>

      <dt><tt>ALUT_ERROR_AL_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an AL error on entry to <tt>alutExit</tt>.</dd>

      <dt><tt>ALUT_ERROR_ALC_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an ALC error on entry to <tt>alutExit</tt>.</dd>

      <dt><tt>ALUT_ERROR_CLOSE_DEVICE</tt></dt>
      <dd>There was an error closing the ALC device created by
      <tt>alutInit</tt>.</dd>

      <dt><tt>ALUT_ERROR_MAKE_CONTEXT_CURRENT</tt></dt>
      <dd>Could not release the current ALC context.</dd>

      <dt><tt>ALUT_ERROR_DESTROY_CONTEXT</tt></dt>
      <dd>There was an error destroying the ALC context created by
      <tt>alutInit</tt>.</dd>
    </dl>

    <h2><a name="Loading"></a>Sound Sample File Loading</h2>

    <p>ALUT attempts to simplify the business of getting a simple application
    running by providing loaders for a range of file formats. Rather than
    enumerate a list of formats that will likely grow with time, the loaders are
    generic and try to do their best either by using OpenAL extensions if
    possible or by converting the sound data into standard OpenAL formats.</p>

    <p>In order to simplify initial startup and to keep test program
    distributions clean, ALUT provides built-in sounds, too, that do not require
    disk I/O because they are built into the ALUT library. These functions may
    be used to write compact ALUT test/example applications with no external
    file dependancies whatsoever. When sending short application programs to
    either the ALUT or OpenAL developers as a part of bug reporting, one should
    endeavor to use these functions instead of loading ones own sound files.</p>

    <p>There are eight (= 4 * 2) different loaders, corresponding to the sources
    and destinations of the sound data. The possible sources are:</p>

    <ul>
      <li>The loaders with a <tt>FromFile</tt> suffix get their sound data from
      a named file.</li>

      <li>The loaders with a <tt>FromFileImage</tt> suffix get their data from a
      continuous memory region. This region can be re-used or destroyed
      afterwards.</li>

      <li>The loaders with a <tt>HelloWorld</tt> suffix get their fixed data
      internally.</li>

      <li>The loaders with a <tt>Waveform</tt> suffix get their data via
      internal waveform calculation.</li>
    </ul>

    <p>The possible destinations are:</p>

    <ul>
      <li>The loaders with a <tt>alutCreateBuffer</tt> prefix create a new
      OpenAL buffer and put the sound data into it. If possible, OpenAL
      extensions are used to avoid conversions at the ALUT level and enable the
      use of possible hardware/driveer features for some sound
      formats. Therefore, these are the preferred loaders.</li>

      <li>The loaders with a <tt>alutLoadMemory</tt> prefix allocate a new
      memory region with <tt>malloc</tt> and put the sound data into it,
      optionally passing back more information about the sound. The sound data
      is guaranteed to be in one of the four standard OpenAL formats (8/16bit
      monon/stereo) aftwerwards.  Because no OpenAL extensions can be used here,
      these loaders might handle fewer sound formats than the
      <tt>alutCreateBuffer</tt> ones.</li>
    </ul>

    <h3 class="manpage"><a name="alutCreateBufferFromFile"></a>alutCreateBufferFromFile</h3>

    <h4>Name</h4>

    <p><tt>alutCreateBufferFromFile</tt> - load a sound file into an OpenAL
    buffer</p>

    <h4>Synopsis</h4>

<pre class="programlisting">ALuint alutCreateBufferFromFile (const char *filename);
</pre>

    <p><tt>alutCreateBufferFromFile</tt> tries to guess the sound data format by
    looking at the filename and/or the file contents and loads the sound data
    into an OpenAL buffer.</p>

    <h4>Return Value</h4>

    <p>On success, <tt>alutCreateBufferFromFile</tt> returns a handle to an
    OpenAL buffer containing the loaded sound. It returns <tt>AL_NONE</tt> on
    failure.</p>

    <h4>Errors</h4>

    <dl>
      <dt><tt>ALUT_ERROR_OUT_OF_MEMORY</tt></dt>
      <dd>ALUT ran out of memory.</dd>

      <dt><tt>ALUT_ERROR_INVALID_OPERATION</tt></dt>
      <dd>ALUT has not been initialised.</dd>

      <dt><tt>ALUT_ERROR_NO_CURRENT_CONTEXT</tt></dt>
      <dd>There is no current AL context.</dd>

      <dt><tt>ALUT_ERROR_AL_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an AL error on entry to
      <tt>alutCreateBufferFromFile</tt>.</dd>

      <dt><tt>ALUT_ERROR_ALC_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an ALC error on entry to
      <tt>alutCreateBufferFromFile</tt>.</dd>

      <dt><tt>ALUT_ERROR_GEN_BUFFERS</tt></dt>
      <dd>There was an error generating an AL buffer.</dd>

      <dt><tt>ALUT_ERROR_BUFFER_DATA</tt></dt>
      <dd>There was an error passing buffer data to AL.</dd>

      <dt><tt>ALUT_ERROR_IO_ERROR</tt></dt>
      <dd>I/O error, consult <tt>errno</tt> for more details.</dd>

      <dt><tt>ALUT_ERROR_UNSUPPORTED_FILE_TYPE</tt></dt>
      <dd>Unsupported file type.</dd>

      <dt><tt>ALUT_ERROR_UNSUPPORTED_FILE_SUBTYPE</tt></dt>
      <dd>Unsupported mode within an otherwise usable file type.</dd>

      <dt><tt>ALUT_ERROR_CORRUPT_OR_TRUNCATED_DATA</tt></dt>
      <dd>The sound data was corrupt or truncated.</dd>
    </dl>

    <h3 class="manpage"><a name="alutCreateBufferFromFileImage"></a>alutCreateBufferFromFileImage</h3>

    <h4>Name</h4>

    <p><tt>alutCreateBufferFromFileImage</tt> - load in-memory sound data into
    an OpenAL buffer</p>

    <h4>Synopsis</h4>

<pre class="programlisting">ALuint alutCreateBufferFromFileImage (const ALvoid *data, ALsizei length);
</pre>

    <p><tt>alutCreateBufferFromFileImage</tt> tries to guess the sound data
    format by looking at the contents of the memory region given as parameters
    and loads the sound data into an OpenAL buffer.</p>

    <h4>Return Value</h4>

    <p>On success, <tt>alutCreateBufferFromFileImage</tt> returns a handle to an
    OpenAL buffer containing the loaded sound. It returns <tt>AL_NONE</tt> on
    failure.</p>

    <h4>Errors</h4>

    <dl>
      <dt><tt>ALUT_ERROR_OUT_OF_MEMORY</tt></dt>
      <dd>ALUT ran out of memory.</dd>

      <dt><tt>ALUT_ERROR_INVALID_OPERATION</tt></dt>
      <dd>ALUT has not been initialised.</dd>

      <dt><tt>ALUT_ERROR_NO_CURRENT_CONTEXT</tt></dt>
      <dd>There is no current AL context.</dd>

      <dt><tt>ALUT_ERROR_AL_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an AL error on entry to
      <tt>alutCreateBufferFromFileImage</tt>.</dd>

      <dt><tt>ALUT_ERROR_ALC_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an ALC error on entry to
      <tt>alutCreateBufferFromFileImage</tt>.</dd>

      <dt><tt>ALUT_ERROR_GEN_BUFFERS</tt></dt>
      <dd>There was an error generating an AL buffer.</dd>

      <dt><tt>ALUT_ERROR_BUFFER_DATA</tt></dt>
      <dd>There was an error passing buffer data to AL.</dd>

      <dt><tt>ALUT_ERROR_UNSUPPORTED_FILE_TYPE</tt></dt>
      <dd>Unsupported file type.</dd>

      <dt><tt>ALUT_ERROR_UNSUPPORTED_FILE_SUBTYPE</tt></dt>
      <dd>Unsupported mode within an otherwise usable file type.</dd>

      <dt><tt>ALUT_ERROR_CORRUPT_OR_TRUNCATED_DATA</tt></dt>
      <dd>The sound data was corrupt or truncated.</dd>
    </dl>

    <h3 class="manpage"><a name="alutCreateBufferHelloWorld"></a>alutCreateBufferHelloWorld</h3>

    <h4>Name</h4>

    <p><tt>alutCreateBufferHelloWorld</tt> - create a buffer with a 'Hello, world!' sound</p>

    <h4>Synopsis</h4>

<pre class="programlisting">ALuint alutCreateBufferHelloWorld (void);
</pre>

    <h4>Description</h4>

    <p><tt>alutCreateBufferHelloWorld</tt> returns a handle to an OpenAL buffer
    containing the sound of someone saying 'Hello, world!'.</p>

    <h4>Return Value</h4>

    <p>On success, <tt>alutCreateBufferHelloWorld</tt> returns a handle to an
    OpenAL buffer containing a 'Hello, world!' sound. It returns
    <tt>AL_NONE</tt> on failure.</p>

    <h4>Errors</h4>

    <dl>
      <dt><tt>ALUT_ERROR_OUT_OF_MEMORY</tt></dt>
      <dd>ALUT ran out of memory.</dd>

      <dt><tt>ALUT_ERROR_INVALID_OPERATION</tt></dt>
      <dd>ALUT has not been initialised.</dd>

      <dt><tt>ALUT_ERROR_NO_CURRENT_CONTEXT</tt></dt>
      <dd>There is no current AL context.</dd>

      <dt><tt>ALUT_ERROR_AL_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an AL error on entry to
      <tt>alutCreateBufferHelloWorld</tt>.</dd>

      <dt><tt>ALUT_ERROR_ALC_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an ALC error on entry to
      <tt>alutCreateBufferHelloWorld</tt>.</dd>

      <dt><tt>ALUT_ERROR_GEN_BUFFERS</tt></dt>
      <dd>There was an error generating an AL buffer.</dd>

      <dt><tt>ALUT_ERROR_BUFFER_DATA</tt></dt>
      <dd>There was an error passing buffer data to AL.</dd>
    </dl>

    <h3 class="manpage"><a name="alutCreateBufferWaveform"></a>alutCreateBufferWaveform</h3>

    <h4>Name</h4>

    <p><tt>alutCreateBufferWaveform</tt> - create a buffer with a synthesized waveform sound</p>

    <h4>Synopsis</h4>

<pre class="programlisting">ALuint alutCreateBufferWaveform (ALenum waveshape,
                                 ALfloat frequency,
                                 ALfloat phase,
                                 ALfloat duration);
</pre>

    <h4>Description</h4>

    <p><tt>alutCreateBufferWaveform</tt> returns a handle to an OpenAL buffer
    containing a snippet of audio with the specified waveshape at the specified
    frequency (in Hertz), phase (in degrees: -180 to +180) and duration (in
    seconds). Allowed waveforms are:</p>

    <ul>
      <li><tt>ALUT_WAVEFORM_SINE</tt></li>
      <li><tt>ALUT_WAVEFORM_SQUARE</tt></li>
      <li><tt>ALUT_WAVEFORM_SAWTOOTH</tt></li>
      <li><tt>ALUT_WAVEFORM_WHITENOISE</tt></li>
      <li><tt>ALUT_WAVEFORM_IMPULSE</tt></li>
    </ul>

    <p>The duration will always be rounded up to an exact number of cycles of
    the sound to avoid a click if you loop the sample. The frequency and phase
    arguments are ignored for <tt>ALUT_WHITENOISE</tt>.</p>

    <h4>Return Value</h4>

    <p>On success, <tt>alutCreateBufferWaveform</tt> returns a handle to an
    OpenAL buffer containing the synthesized waveform. It returns
    <tt>AL_NONE</tt> on failure.</p>

    <h4>Errors</h4>

    <dl>
      <dt><tt>ALUT_ERROR_OUT_OF_MEMORY</tt></dt>
      <dd>ALUT ran out of memory.</dd>

      <dt><tt>ALUT_ERROR_INVALID_ENUM</tt></dt>
      <dd>An invalid waveform token was given to
      <tt>alutCreateBufferWaveform</tt>.</dd>

      <dt><tt>ALUT_ERROR_INVALID_VALUE</tt></dt>
      <dd>The frequency was not positive or the duration was negative.</dd>

      <dt><tt>ALUT_ERROR_INVALID_OPERATION</tt></dt>
      <dd>ALUT has not been initialised.</dd>

      <dt><tt>ALUT_ERROR_NO_CURRENT_CONTEXT</tt></dt>
      <dd>There is no current AL context.</dd>

      <dt><tt>ALUT_ERROR_AL_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an AL error on entry to
      <tt>alutCreateBufferWaveform</tt>.</dd>

      <dt><tt>ALUT_ERROR_ALC_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an ALC error on entry to
      <tt>alutCreateBufferWaveform</tt>.</dd>

      <dt><tt>ALUT_ERROR_GEN_BUFFERS</tt></dt>
      <dd>There was an error generating an AL buffer.</dd>

      <dt><tt>ALUT_ERROR_BUFFER_DATA</tt></dt>
      <dd>There was an error passing buffer data to AL.</dd>
    </dl>

    <h3 class="manpage"><a name="alutLoadMemoryFromFile"></a>alutLoadMemoryFromFile</h3>

    <h4>Name</h4>

    <p><tt>alutLoadMemoryFromFile</tt> - load a sound file into OpenAL-like
    data</p>

    <h4>Synopsis</h4>

<pre class="programlisting">ALvoid *alutLoadMemoryFromFile (const char *filename,
                                ALenum *format,
                                ALsizei *size,
                                ALfloat *frequency);
</pre>

    <p><tt>alutLoadMemoryFromFile</tt> tries to guess the sound data format by
    looking at the filename and/or the file contents and loads the sound data
    into a newly <tt>malloc</tt>ed buffer, possibly converting it in the
    process. The format is guaranteed to be a standard OpenAL format
    afterwards.</p>

    <h4>Return Value</h4>

    <p>On success, <tt>alutLoadMemoryFromFile</tt> returns a pointer to a newly
    allocated memory area containing the sound data, which can be <tt>free</tt>d
    if not needed anymore. It returns <tt>NULL</tt> on failure. If any of the
    format, size or frequency parameters are non-<tt>NULL</tt>, the respective
    information about the sound will be passed back.</p>

    <h4>Errors</h4>

    <dl>
      <dt><tt>ALUT_ERROR_OUT_OF_MEMORY</tt></dt>
      <dd>ALUT ran out of memory.</dd>

      <dt><tt>ALUT_ERROR_INVALID_OPERATION</tt></dt>
      <dd>ALUT has not been initialised.</dd>

      <dt><tt>ALUT_ERROR_NO_CURRENT_CONTEXT</tt></dt>
      <dd>There is no current AL context.</dd>

      <dt><tt>ALUT_ERROR_AL_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an AL error on entry to
      <tt>alutLoadMemoryFromFile</tt>.</dd>

      <dt><tt>ALUT_ERROR_ALC_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an ALC error on entry to
      <tt>alutLoadMemoryFromFile</tt>.</dd>

      <dt><tt>ALUT_ERROR_IO_ERROR</tt></dt>
      <dd>I/O error, consult <tt>errno</tt> for more details.</dd>

      <dt><tt>ALUT_ERROR_UNSUPPORTED_FILE_TYPE</tt></dt>
      <dd>Unsupported file type.</dd>

      <dt><tt>ALUT_ERROR_UNSUPPORTED_FILE_SUBTYPE</tt></dt>
      <dd>Unsupported mode within an otherwise usable file type.</dd>

      <dt><tt>ALUT_ERROR_CORRUPT_OR_TRUNCATED_DATA</tt></dt>
      <dd>The sound data was corrupt or truncated.</dd>
    </dl>

    <h3 class="manpage"><a name="alutLoadMemoryFromFileImage"></a>alutLoadMemoryFromFileImage</h3>

    <h4>Name</h4>

    <p><tt>alutLoadMemoryFromFileImage</tt> - convert in-memory sound data into
    OpenAL-like data</p>

    <h4>Synopsis</h4>

<pre class="programlisting">ALvoid *alutLoadMemoryFromFileImage (const ALvoid *data,
                                     ALsizei length,
                                     ALenum *format,
                                     ALsizei *size,
                                     ALfloat *frequency);
</pre>

    <p><tt>alutLoadMemoryFromFileImage</tt> tries to guess the sound data format
    by looking at the contents of the memory region given as the first two
    arguments and loads the sound data into a newly <tt>malloc</tt>ed buffer,
    possibly converting it in the process. The format is guaranteed to be a
    standard OpenAL format afterwards.</p>

    <h4>Return Value</h4>

    <p>On success, <tt>alutLoadMemoryFromFileImage</tt> returns a pointer to a
    newly allocated memory area containing the sound data, which can be
    <tt>free</tt>d if not needed anymore. It returns <tt>NULL</tt> on
    failure. If any of the format, size or frequency parameters are
    non-<tt>NULL</tt>, the respective information about the sound will be passed
    back.</p>

    <h4>Errors</h4>

    <dl>
      <dt><tt>ALUT_ERROR_OUT_OF_MEMORY</tt></dt>
      <dd>ALUT ran out of memory.</dd>

      <dt><tt>ALUT_ERROR_INVALID_OPERATION</tt></dt>
      <dd>ALUT has not been initialised.</dd>

      <dt><tt>ALUT_ERROR_NO_CURRENT_CONTEXT</tt></dt>
      <dd>There is no current AL context.</dd>

      <dt><tt>ALUT_ERROR_AL_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an AL error on entry to
      <tt>alutLoadMemoryFromFileImage</tt>.</dd>

      <dt><tt>ALUT_ERROR_ALC_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an ALC error on entry to
      <tt>alutLoadMemoryFromFileImage</tt>.</dd>

      <dt><tt>ALUT_ERROR_UNSUPPORTED_FILE_TYPE</tt></dt>
      <dd>Unsupported file type.</dd>

      <dt><tt>ALUT_ERROR_UNSUPPORTED_FILE_SUBTYPE</tt></dt>
      <dd>Unsupported mode within an otherwise usable file type.</dd>

      <dt><tt>ALUT_ERROR_CORRUPT_OR_TRUNCATED_DATA</tt></dt>
      <dd>The sound data was corrupt or truncated.</dd>
    </dl>

    <h3 class="manpage"><a name="alutLoadMemoryHelloWorld"></a>alutLoadMemoryHelloWorld</h3>

    <h4>Name</h4>

    <p><tt>alutLoadMemoryHelloWorld</tt> - load a 'Hello, world!' sound into
    OpenAL-like data</p>

    <h4>Synopsis</h4>

<pre class="programlisting">ALvoid *alutLoadMemoryHelloWorld (ALenum *format,
                                  ALsizei *size,
                                  ALfloat *frequency);

</pre>

    <h4>Description</h4>

    <p><tt>alutLoadMemoryHelloWorld</tt> loads the sound of someone saying
    'Hello, world!' into a newly <tt>malloc</tt>ed buffer. The sound data is
    guaranteed to be in a standard OpenAL format, with a sample frequency chosen
    by the ALUT implementation.</p>

    <h4>Return Value</h4>

    <p>On success, <tt>alutLoadMemoryHelloWorld</tt> returns a pointer to a
    newly allocated memory area containing the sound data, which can be
    <tt>free</tt>d if not needed anymore. It returns <tt>NULL</tt> on
    failure. If any of the format, size or frequency parameters are
    non-<tt>NULL</tt>, the respective information about the sound will be passed
    back.</p>

    <h4>Errors</h4>

    <dl>
      <dt><tt>ALUT_ERROR_OUT_OF_MEMORY</tt></dt>
      <dd>ALUT ran out of memory.</dd>

      <dt><tt>ALUT_ERROR_INVALID_OPERATION</tt></dt>
      <dd>ALUT has not been initialised.</dd>

      <dt><tt>ALUT_ERROR_NO_CURRENT_CONTEXT</tt></dt>
      <dd>There is no current AL context.</dd>

      <dt><tt>ALUT_ERROR_AL_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an AL error on entry to
      <tt>alutLoadMemoryHelloWorld</tt>.</dd>

      <dt><tt>ALUT_ERROR_ALC_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an ALC error on entry to
      <tt>alutLoadMemoryHelloWorld</tt>.</dd>
    </dl>

    <h3 class="manpage"><a name="alutLoadMemoryWaveform"></a>alutLoadMemoryWaveform</h3>

    <h4>Name</h4>

    <p><tt>alutLoadMemoryWaveform</tt> - load a synthesized waveform sound into
    OpenAL-like data</p>

    <h4>Synopsis</h4>

<pre class="programlisting">ALvoid *alutLoadMemoryWaveform (ALenum waveshape,
                                ALfloat frequency,
                                ALfloat phase,
                                ALfloat duration,
                                ALenum *format,
                                ALsizei *size,
                                ALfloat *sampleFrequency);
</pre>

    <h4>Description</h4>

    <p><tt>alutLoadMemoryWaveform</tt> loads a snippet of audio with the
    specified waveshape at the specified frequency (in Hertz), phase (in
    degrees: -180 to +180) and duration (in seconds) into a newly
    <tt>malloc</tt>ed buffer. The sound data is guaranteed to be in a standard
    OpenAL format, with a sample frequency chosen by the ALUT
    implementation. Allowed waveforms are:</p>

    <ul>
      <li><tt>ALUT_WAVEFORM_SINE</tt></li>
      <li><tt>ALUT_WAVEFORM_SQUARE</tt></li>
      <li><tt>ALUT_WAVEFORM_SAWTOOTH</tt></li>
      <li><tt>ALUT_WAVEFORM_WHITENOISE</tt></li>
      <li><tt>ALUT_WAVEFORM_IMPULSE</tt></li>
    </ul>

    <p>The duration will always be rounded up to an exact number of cycles of
    the sound to avoid a click if you loop the sample. The frequency and phase
    arguments are ignored for <tt>ALUT_WHITENOISE</tt>.</p>

    <h4>Return Value</h4>

    <p>On success, <tt>alutLoadMemoryWaveform</tt> returns a pointer to a newly
    allocated memory area containing the sound data, which can be <tt>free</tt>d
    if not needed anymore. It returns <tt>NULL</tt> on failure. If any of the
    format, size or sample frequency parameters are non-<tt>NULL</tt>, the
    respective information about the sound will be passed back.</p>

    <h4>Errors</h4>

    <dl>
      <dt><tt>ALUT_ERROR_OUT_OF_MEMORY</tt></dt>
      <dd>ALUT ran out of memory.</dd>

      <dt><tt>ALUT_ERROR_INVALID_ENUM</tt></dt>
      <dd>An invalid waveform token was given to
      <tt>alutLoadMemoryWaveform</tt>.</dd>

      <dt><tt>ALUT_ERROR_INVALID_VALUE</tt></dt>
      <dd>The frequency was not positive or the duration was negative.</dd>

      <dt><tt>ALUT_ERROR_INVALID_OPERATION</tt></dt>
      <dd>ALUT has not been initialised.</dd>

      <dt><tt>ALUT_ERROR_NO_CURRENT_CONTEXT</tt></dt>
      <dd>There is no current AL context.</dd>

      <dt><tt>ALUT_ERROR_AL_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an AL error on entry to
      <tt>alutLoadMemoryWaveform</tt>.</dd>

      <dt><tt>ALUT_ERROR_ALC_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an ALC error on entry to
      <tt>alutLoadMemoryWaveform</tt>.</dd>
    </dl>

    <h3 class="manpage"><a name="alutGetMIMETypes"></a>alutGetMIMETypes</h3>

    <h4>Name</h4>

    <p><tt>alutGetMIMETypes</tt> - get list support supported audio MIME types</p>

    <h4>Synopsis</h4>

<pre class="programlisting">const char *alutGetMIMETypes (ALenum loader);
</pre>

    <h4>Description</h4>

    <p><tt>alutGetMIMETypes</tt> returns a comma-separated list of
    supported MIME types for the given loader type, e.g. something like
    &quot;<tt>audio/basic,audio/mpeg,audio/x-wav</tt>&quot;. Allowed loader
    types are:</p>

    <dl>
      <dt><tt>ALUT_LOADER_BUFFER</tt></dt>

      <dd>For the loaders returning sound data in an OpenAL buffer,
      e.g. <tt>alutCreateBufferFromFile</tt> and
      <tt>alutCreateBufferFromFileImage</tt></dd>

      <dt><tt>ALUT_LOADER_MEMORY</tt></dt>

      <dd>For the loaders returning sound data in a newly allocated memory
      region, e.g. <tt>alutLoadMemoryFromFile</tt> and
      <tt>alutLoadMemoryFromFileImage</tt></dd>
    </dl>

    <p>It is possible that <tt>ALUT_LOADER_MEMORY</tt> loaders will be unable to
    support some file types that <tt>ALUT_LOADER_BUFFER</tt> loaders can support
    (although the reverse is never the case). Furthermore, it is possible that
    for some file types (notably audio/x-wav) the support may be only for a few
    sub-formats. For example, an implementation may advertise that audio/x-wav
    is supported when in fact it only supports uncompressed (i.e. PCM) WAV files
    and not any of the compressed subformats. In this event, the various ALUT
    loaders may return an error and set
    <tt>ALUT_ERROR_UNSUPPORTED_FILE_SUBTYPE</tt> rather than
    <tt>ALUT_ERROR_UNSUPPORTED_FILE_TYPE</tt> which would indicate that no files
    of this type are allowed.</p>

    <h4>Return Value</h4>

    <p>On success, <tt>alutGetMIMETypes</tt> returns a zero-terminated string
    which contains a comma-separated list of supported MIME types. It returns
    <tt>NULL</tt> on failure.</p>

    <h4>Errors</h4>

    <dl>
      <dt><tt>ALUT_ERROR_INVALID_ENUM</tt></dt>
      <dd><tt>alutGetMIMETypes</tt> was given an invalid loader token.</dd>

      <dt><tt>ALUT_ERROR_INVALID_OPERATION</tt></dt>
      <dd>ALUT has not been initialised.</dd>

      <dt><tt>ALUT_ERROR_NO_CURRENT_CONTEXT</tt></dt>
      <dd>There is no current AL context.</dd>

      <dt><tt>ALUT_ERROR_AL_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an AL error on entry to
      <tt>alutGetMIMETypes</tt>.</dd>

      <dt><tt>ALUT_ERROR_ALC_ERROR_ON_ENTRY</tt></dt>
      <dd>There was already an ALC error on entry to
      <tt>alutGetMIMETypes</tt>.</dd>
    </dl>

    <h3><a name="DeprecatedWAVLoaders"></a>Deprecated WAV loaders</h3>

    <p>For backwards-compatibility with ALUT 0.x.x, ALUT still offers the three
    deprecated functions below. Note that on MacOS 0.x.x version, the
    '<tt>loop</tt>' parameter is omitted from both loader functions.</p>

<pre class="programlisting">void alutLoadWAVFile (ALbyte *filename,
                      ALenum *format,
                      void **data,
                      ALsizei *size,
                      ALsizei *frequency,
                      ALboolean *loop);

void alutLoadWAVMemory (ALbyte *buffer,
                        ALenum *format,
                        void **data,
                        ALsizei *size,
                        ALsizei *frequency,
                        ALboolean *loop);

void alutUnloadWAV (ALenum format ALvoid *data, ALsizei size, ALsizei frequency);
</pre>

    <h2><a name="VersionChecking"></a>Version Checking</h2>

    <p>ALUT version numbers consist of a major version number, a minor version
    number, and a patchlevel. The former two numbers will match the major/minor
    version number of the corresponding ALUT specification document and can be
    accessed at compile time as well as runtime. The patchlevel is not
    programmatically available and it is incremented only when fixing bugs
    without any API changes.</p>

    <h3 class="manpage"><a name="alutGetMajorVersion"></a>alutGetMajorVersion</h3>

    <h4>Name</h4>

    <p><tt>alutGetMajorVersion</tt> - return the major ALUT version number</p>

    <h4>Synopsis</h4>

<pre class="programlisting">ALint alutGetMajorVersion (void);
</pre>

    <h4>Description</h4>

    <p><tt>alutGetMajorVersion</tt> returns the major version number of the ALUT
    in use, which will match the major version number of the corresponding ALUT
    specification document.</p>

    <h4>Return Value</h4>

    <p><tt>alutGetMajorVersion</tt> returns the major version number of the ALUT
    in use.</p>

    <h4>Errors</h4>

    <p><tt>alutGetMajorVersion</tt> can be called in any ALUT state and will
    never fail.</p>

    <h3 class="manpage"><a name="alutGetMinorVersion"></a>alutGetMinorVersion</h3>

    <h4>Name</h4>

    <p><tt>alutGetMinorVersion</tt> - return the minor ALUT version number</p>

    <h4>Synopsis</h4>

<pre class="programlisting">ALint alutGetMinorVersion (void);
</pre>

    <h4>Description</h4>

    <p><tt>alutGetMinorVersion</tt> returns the minor version number of the ALUT
    in use, which will match the minor version number of the corresponding ALUT
    specification document.</p>

    <h4>Return Value</h4>

    <p><tt>alutGetMinorVersion</tt> returns the minor version number of the ALUT
    in use.</p>

    <h4>Errors</h4>

    <p><tt>alutGetMinorVersion</tt> can be called in any ALUT state and will
    never fail.</p>

    <h3><a name="VersioningMacros"></a>Compile Time Version Checking</h3>

<pre class="programlisting">#define ALUT_API_MAJOR_VERSION 1

#define ALUT_API_MINOR_VERSION 1
</pre>

    <p>Version 1.0.0 introduced the above preprocessor symbols, whose values
    will be incremented appropriately in future revisions of ALUT. In version
    1.1.0, <tt>alutLoadMemoryHelloWorld</tt> and <tt>alutLoadMemoryWaveform</tt>
    have been added to the ALUT API.</p>

    <div class="example">
      <h4>Example: Version consistency check</h4>

      <p>Applications can verify at runtime that they have been compiled and
      linked with the matching header file and library file as follows:</p>

<pre class="programlisting">#ifdef ALUT_API_MAJOR_VERSION
if (alutGetMajorVersion () != ALUT_API_MAJOR_VERSION ||
    alutGetMinorVersion () != ALUT_API_MINOR_VERSION)
  /* Oh-oh!  The ALUT header and the ALUT library are different revisions... */
#else
  /* Oh-oh!  We're linking against an ALUT 0.x.x header file... */
#endif
</pre>
    </div>

    <h2><a name="Sleeping"></a>Sleeping</h2>

    <p>Having a general utility function like the following in an audio-related
    toolkit might seem strange at first, but sleeping is a common task in a lot
    of audio demos and it can't be done portably without cluttering the source
    code with <tt>#ifdefs</tt>.</p>

    <h3 class="manpage"><a name="alutSleep"></a>alutSleep</h3>

    <h4>Name</h4>

    <p><tt>alutSleep</tt> - sleep for a given number of seconds</p>

    <h4>Synopsis</h4>

<pre class="programlisting">ALboolean alutSleep (ALfloat duration);
</pre>

    <h4>Description</h4>

    <p><tt>alutSleep</tt> will delay the execution of the current thread for at
    least the given amount of seconds. It will only return earlier if a signal
    has been delivered to the thread, but this does not count as an error. Note
    that sleeping for zero seconds will give other runnable threads a chance to
    run.</p>

    <h4>Return Value</h4>

    <p><tt>alutSleep</tt> returns <tt>AL_TRUE</tt> on success or
    <tt>AL_FALSE</tt> on failure. Note that current implementations will always
    succeed if the duration is non-negative, but this might change in the
    future.</p>

    <h4>Errors</h4>

    <dl>
      <dt><tt>ALUT_ERROR_INVALID_VALUE</tt></dt>
      <dd><tt>alutSleep</tt> was given a negative duration.</dd>
    </dl>

  </body>
</html>
<!-- Emacs stuff:
     ;;; Local Variables: ***
     ;;; mode: xml ***
     ;;; End: ***
 -->
